// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: pkg/api/proto/gateway/gateway.proto

package gateway

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GatewayService_ProcessAIRequest_FullMethodName    = "/exoper.gateway.v1.GatewayService/ProcessAIRequest"
	GatewayService_StreamAIRequest_FullMethodName     = "/exoper.gateway.v1.GatewayService/StreamAIRequest"
	GatewayService_ValidateRequest_FullMethodName     = "/exoper.gateway.v1.GatewayService/ValidateRequest"
	GatewayService_GetHealth_FullMethodName           = "/exoper.gateway.v1.GatewayService/GetHealth"
	GatewayService_GetMetrics_FullMethodName          = "/exoper.gateway.v1.GatewayService/GetMetrics"
	GatewayService_GetRoutingInfo_FullMethodName      = "/exoper.gateway.v1.GatewayService/GetRoutingInfo"
	GatewayService_ProcessBatchRequest_FullMethodName = "/exoper.gateway.v1.GatewayService/ProcessBatchRequest"
	GatewayService_CheckModelAccess_FullMethodName    = "/exoper.gateway.v1.GatewayService/CheckModelAccess"
)

// GatewayServiceClient is the client API for GatewayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayServiceClient interface {
	ProcessAIRequest(ctx context.Context, in *ProcessAIRequestRequest, opts ...grpc.CallOption) (*ProcessAIRequestResponse, error)
	StreamAIRequest(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamAIRequestRequest, StreamAIRequestResponse], error)
	ValidateRequest(ctx context.Context, in *ValidateRequestRequest, opts ...grpc.CallOption) (*ValidateRequestResponse, error)
	GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error)
	GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error)
	GetRoutingInfo(ctx context.Context, in *GetRoutingInfoRequest, opts ...grpc.CallOption) (*GetRoutingInfoResponse, error)
	ProcessBatchRequest(ctx context.Context, in *BatchRequestProto, opts ...grpc.CallOption) (*BatchResponseProto, error)
	CheckModelAccess(ctx context.Context, in *ModelAccessRequest, opts ...grpc.CallOption) (*ModelAccessResponse, error)
}

type gatewayServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayServiceClient(cc grpc.ClientConnInterface) GatewayServiceClient {
	return &gatewayServiceClient{cc}
}

func (c *gatewayServiceClient) ProcessAIRequest(ctx context.Context, in *ProcessAIRequestRequest, opts ...grpc.CallOption) (*ProcessAIRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessAIRequestResponse)
	err := c.cc.Invoke(ctx, GatewayService_ProcessAIRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) StreamAIRequest(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamAIRequestRequest, StreamAIRequestResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GatewayService_ServiceDesc.Streams[0], GatewayService_StreamAIRequest_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamAIRequestRequest, StreamAIRequestResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamAIRequestClient = grpc.BidiStreamingClient[StreamAIRequestRequest, StreamAIRequestResponse]

func (c *gatewayServiceClient) ValidateRequest(ctx context.Context, in *ValidateRequestRequest, opts ...grpc.CallOption) (*ValidateRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateRequestResponse)
	err := c.cc.Invoke(ctx, GatewayService_ValidateRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHealthResponse)
	err := c.cc.Invoke(ctx, GatewayService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMetricsResponse)
	err := c.cc.Invoke(ctx, GatewayService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GetRoutingInfo(ctx context.Context, in *GetRoutingInfoRequest, opts ...grpc.CallOption) (*GetRoutingInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutingInfoResponse)
	err := c.cc.Invoke(ctx, GatewayService_GetRoutingInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) ProcessBatchRequest(ctx context.Context, in *BatchRequestProto, opts ...grpc.CallOption) (*BatchResponseProto, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchResponseProto)
	err := c.cc.Invoke(ctx, GatewayService_ProcessBatchRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) CheckModelAccess(ctx context.Context, in *ModelAccessRequest, opts ...grpc.CallOption) (*ModelAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelAccessResponse)
	err := c.cc.Invoke(ctx, GatewayService_CheckModelAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServiceServer is the server API for GatewayService service.
// All implementations must embed UnimplementedGatewayServiceServer
// for forward compatibility.
type GatewayServiceServer interface {
	ProcessAIRequest(context.Context, *ProcessAIRequestRequest) (*ProcessAIRequestResponse, error)
	StreamAIRequest(grpc.BidiStreamingServer[StreamAIRequestRequest, StreamAIRequestResponse]) error
	ValidateRequest(context.Context, *ValidateRequestRequest) (*ValidateRequestResponse, error)
	GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error)
	GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error)
	GetRoutingInfo(context.Context, *GetRoutingInfoRequest) (*GetRoutingInfoResponse, error)
	ProcessBatchRequest(context.Context, *BatchRequestProto) (*BatchResponseProto, error)
	CheckModelAccess(context.Context, *ModelAccessRequest) (*ModelAccessResponse, error)
	mustEmbedUnimplementedGatewayServiceServer()
}

// UnimplementedGatewayServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGatewayServiceServer struct{}

func (UnimplementedGatewayServiceServer) ProcessAIRequest(context.Context, *ProcessAIRequestRequest) (*ProcessAIRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessAIRequest not implemented")
}
func (UnimplementedGatewayServiceServer) StreamAIRequest(grpc.BidiStreamingServer[StreamAIRequestRequest, StreamAIRequestResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamAIRequest not implemented")
}
func (UnimplementedGatewayServiceServer) ValidateRequest(context.Context, *ValidateRequestRequest) (*ValidateRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateRequest not implemented")
}
func (UnimplementedGatewayServiceServer) GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedGatewayServiceServer) GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedGatewayServiceServer) GetRoutingInfo(context.Context, *GetRoutingInfoRequest) (*GetRoutingInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutingInfo not implemented")
}
func (UnimplementedGatewayServiceServer) ProcessBatchRequest(context.Context, *BatchRequestProto) (*BatchResponseProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessBatchRequest not implemented")
}
func (UnimplementedGatewayServiceServer) CheckModelAccess(context.Context, *ModelAccessRequest) (*ModelAccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckModelAccess not implemented")
}
func (UnimplementedGatewayServiceServer) mustEmbedUnimplementedGatewayServiceServer() {}
func (UnimplementedGatewayServiceServer) testEmbeddedByValue()                        {}

// UnsafeGatewayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServiceServer will
// result in compilation errors.
type UnsafeGatewayServiceServer interface {
	mustEmbedUnimplementedGatewayServiceServer()
}

func RegisterGatewayServiceServer(s grpc.ServiceRegistrar, srv GatewayServiceServer) {
	// If the following call pancis, it indicates UnimplementedGatewayServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GatewayService_ServiceDesc, srv)
}

func _GatewayService_ProcessAIRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessAIRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).ProcessAIRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_ProcessAIRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).ProcessAIRequest(ctx, req.(*ProcessAIRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_StreamAIRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GatewayServiceServer).StreamAIRequest(&grpc.GenericServerStream[StreamAIRequestRequest, StreamAIRequestResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamAIRequestServer = grpc.BidiStreamingServer[StreamAIRequestRequest, StreamAIRequestResponse]

func _GatewayService_ValidateRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).ValidateRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_ValidateRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).ValidateRequest(ctx, req.(*ValidateRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GetHealth(ctx, req.(*GetHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GetMetrics(ctx, req.(*GetMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GetRoutingInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutingInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GetRoutingInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GetRoutingInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GetRoutingInfo(ctx, req.(*GetRoutingInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_ProcessBatchRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).ProcessBatchRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_ProcessBatchRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).ProcessBatchRequest(ctx, req.(*BatchRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_CheckModelAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModelAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).CheckModelAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_CheckModelAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).CheckModelAccess(ctx, req.(*ModelAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayService_ServiceDesc is the grpc.ServiceDesc for GatewayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "exoper.gateway.v1.GatewayService",
	HandlerType: (*GatewayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessAIRequest",
			Handler:    _GatewayService_ProcessAIRequest_Handler,
		},
		{
			MethodName: "ValidateRequest",
			Handler:    _GatewayService_ValidateRequest_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _GatewayService_GetHealth_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _GatewayService_GetMetrics_Handler,
		},
		{
			MethodName: "GetRoutingInfo",
			Handler:    _GatewayService_GetRoutingInfo_Handler,
		},
		{
			MethodName: "ProcessBatchRequest",
			Handler:    _GatewayService_ProcessBatchRequest_Handler,
		},
		{
			MethodName: "CheckModelAccess",
			Handler:    _GatewayService_CheckModelAccess_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAIRequest",
			Handler:       _GatewayService_StreamAIRequest_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/api/proto/gateway/gateway.proto",
}

const (
	GatewayManagementService_GetConfiguration_FullMethodName    = "/exoper.gateway.v1.GatewayManagementService/GetConfiguration"
	GatewayManagementService_UpdateConfiguration_FullMethodName = "/exoper.gateway.v1.GatewayManagementService/UpdateConfiguration"
	GatewayManagementService_GetAuditLogs_FullMethodName        = "/exoper.gateway.v1.GatewayManagementService/GetAuditLogs"
	GatewayManagementService_GetSystemInfo_FullMethodName       = "/exoper.gateway.v1.GatewayManagementService/GetSystemInfo"
	GatewayManagementService_ReloadConfiguration_FullMethodName = "/exoper.gateway.v1.GatewayManagementService/ReloadConfiguration"
)

// GatewayManagementServiceClient is the client API for GatewayManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayManagementServiceClient interface {
	GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*GetConfigurationResponse, error)
	UpdateConfiguration(ctx context.Context, in *UpdateConfigurationRequest, opts ...grpc.CallOption) (*UpdateConfigurationResponse, error)
	GetAuditLogs(ctx context.Context, in *GetAuditLogsRequest, opts ...grpc.CallOption) (*GetAuditLogsResponse, error)
	GetSystemInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSystemInfoResponse, error)
	ReloadConfiguration(ctx context.Context, in *ReloadConfigurationRequest, opts ...grpc.CallOption) (*ReloadConfigurationResponse, error)
}

type gatewayManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayManagementServiceClient(cc grpc.ClientConnInterface) GatewayManagementServiceClient {
	return &gatewayManagementServiceClient{cc}
}

func (c *gatewayManagementServiceClient) GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*GetConfigurationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConfigurationResponse)
	err := c.cc.Invoke(ctx, GatewayManagementService_GetConfiguration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayManagementServiceClient) UpdateConfiguration(ctx context.Context, in *UpdateConfigurationRequest, opts ...grpc.CallOption) (*UpdateConfigurationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateConfigurationResponse)
	err := c.cc.Invoke(ctx, GatewayManagementService_UpdateConfiguration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayManagementServiceClient) GetAuditLogs(ctx context.Context, in *GetAuditLogsRequest, opts ...grpc.CallOption) (*GetAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuditLogsResponse)
	err := c.cc.Invoke(ctx, GatewayManagementService_GetAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayManagementServiceClient) GetSystemInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSystemInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemInfoResponse)
	err := c.cc.Invoke(ctx, GatewayManagementService_GetSystemInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayManagementServiceClient) ReloadConfiguration(ctx context.Context, in *ReloadConfigurationRequest, opts ...grpc.CallOption) (*ReloadConfigurationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReloadConfigurationResponse)
	err := c.cc.Invoke(ctx, GatewayManagementService_ReloadConfiguration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayManagementServiceServer is the server API for GatewayManagementService service.
// All implementations must embed UnimplementedGatewayManagementServiceServer
// for forward compatibility.
type GatewayManagementServiceServer interface {
	GetConfiguration(context.Context, *GetConfigurationRequest) (*GetConfigurationResponse, error)
	UpdateConfiguration(context.Context, *UpdateConfigurationRequest) (*UpdateConfigurationResponse, error)
	GetAuditLogs(context.Context, *GetAuditLogsRequest) (*GetAuditLogsResponse, error)
	GetSystemInfo(context.Context, *emptypb.Empty) (*GetSystemInfoResponse, error)
	ReloadConfiguration(context.Context, *ReloadConfigurationRequest) (*ReloadConfigurationResponse, error)
	mustEmbedUnimplementedGatewayManagementServiceServer()
}

// UnimplementedGatewayManagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGatewayManagementServiceServer struct{}

func (UnimplementedGatewayManagementServiceServer) GetConfiguration(context.Context, *GetConfigurationRequest) (*GetConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfiguration not implemented")
}
func (UnimplementedGatewayManagementServiceServer) UpdateConfiguration(context.Context, *UpdateConfigurationRequest) (*UpdateConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfiguration not implemented")
}
func (UnimplementedGatewayManagementServiceServer) GetAuditLogs(context.Context, *GetAuditLogsRequest) (*GetAuditLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditLogs not implemented")
}
func (UnimplementedGatewayManagementServiceServer) GetSystemInfo(context.Context, *emptypb.Empty) (*GetSystemInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedGatewayManagementServiceServer) ReloadConfiguration(context.Context, *ReloadConfigurationRequest) (*ReloadConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadConfiguration not implemented")
}
func (UnimplementedGatewayManagementServiceServer) mustEmbedUnimplementedGatewayManagementServiceServer() {
}
func (UnimplementedGatewayManagementServiceServer) testEmbeddedByValue() {}

// UnsafeGatewayManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayManagementServiceServer will
// result in compilation errors.
type UnsafeGatewayManagementServiceServer interface {
	mustEmbedUnimplementedGatewayManagementServiceServer()
}

func RegisterGatewayManagementServiceServer(s grpc.ServiceRegistrar, srv GatewayManagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedGatewayManagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GatewayManagementService_ServiceDesc, srv)
}

func _GatewayManagementService_GetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayManagementServiceServer).GetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayManagementService_GetConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayManagementServiceServer).GetConfiguration(ctx, req.(*GetConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayManagementService_UpdateConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayManagementServiceServer).UpdateConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayManagementService_UpdateConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayManagementServiceServer).UpdateConfiguration(ctx, req.(*UpdateConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayManagementService_GetAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayManagementServiceServer).GetAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayManagementService_GetAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayManagementServiceServer).GetAuditLogs(ctx, req.(*GetAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayManagementService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayManagementServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayManagementService_GetSystemInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayManagementServiceServer).GetSystemInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayManagementService_ReloadConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayManagementServiceServer).ReloadConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayManagementService_ReloadConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayManagementServiceServer).ReloadConfiguration(ctx, req.(*ReloadConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayManagementService_ServiceDesc is the grpc.ServiceDesc for GatewayManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "exoper.gateway.v1.GatewayManagementService",
	HandlerType: (*GatewayManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfiguration",
			Handler:    _GatewayManagementService_GetConfiguration_Handler,
		},
		{
			MethodName: "UpdateConfiguration",
			Handler:    _GatewayManagementService_UpdateConfiguration_Handler,
		},
		{
			MethodName: "GetAuditLogs",
			Handler:    _GatewayManagementService_GetAuditLogs_Handler,
		},
		{
			MethodName: "GetSystemInfo",
			Handler:    _GatewayManagementService_GetSystemInfo_Handler,
		},
		{
			MethodName: "ReloadConfiguration",
			Handler:    _GatewayManagementService_ReloadConfiguration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/proto/gateway/gateway.proto",
}

const (
	GatewayMonitoringService_GetRealTimeMetrics_FullMethodName = "/exoper.gateway.v1.GatewayMonitoringService/GetRealTimeMetrics"
	GatewayMonitoringService_GetAlerts_FullMethodName          = "/exoper.gateway.v1.GatewayMonitoringService/GetAlerts"
	GatewayMonitoringService_CreateAlert_FullMethodName        = "/exoper.gateway.v1.GatewayMonitoringService/CreateAlert"
	GatewayMonitoringService_UpdateAlert_FullMethodName        = "/exoper.gateway.v1.GatewayMonitoringService/UpdateAlert"
	GatewayMonitoringService_DeleteAlert_FullMethodName        = "/exoper.gateway.v1.GatewayMonitoringService/DeleteAlert"
)

// GatewayMonitoringServiceClient is the client API for GatewayMonitoringService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayMonitoringServiceClient interface {
	GetRealTimeMetrics(ctx context.Context, in *GetRealTimeMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MetricData], error)
	GetAlerts(ctx context.Context, in *GetAlertsRequest, opts ...grpc.CallOption) (*GetAlertsResponse, error)
	CreateAlert(ctx context.Context, in *CreateAlertRequest, opts ...grpc.CallOption) (*CreateAlertResponse, error)
	UpdateAlert(ctx context.Context, in *UpdateAlertRequest, opts ...grpc.CallOption) (*UpdateAlertResponse, error)
	DeleteAlert(ctx context.Context, in *DeleteAlertRequest, opts ...grpc.CallOption) (*DeleteAlertResponse, error)
}

type gatewayMonitoringServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayMonitoringServiceClient(cc grpc.ClientConnInterface) GatewayMonitoringServiceClient {
	return &gatewayMonitoringServiceClient{cc}
}

func (c *gatewayMonitoringServiceClient) GetRealTimeMetrics(ctx context.Context, in *GetRealTimeMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MetricData], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GatewayMonitoringService_ServiceDesc.Streams[0], GatewayMonitoringService_GetRealTimeMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetRealTimeMetricsRequest, MetricData]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayMonitoringService_GetRealTimeMetricsClient = grpc.ServerStreamingClient[MetricData]

func (c *gatewayMonitoringServiceClient) GetAlerts(ctx context.Context, in *GetAlertsRequest, opts ...grpc.CallOption) (*GetAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAlertsResponse)
	err := c.cc.Invoke(ctx, GatewayMonitoringService_GetAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayMonitoringServiceClient) CreateAlert(ctx context.Context, in *CreateAlertRequest, opts ...grpc.CallOption) (*CreateAlertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAlertResponse)
	err := c.cc.Invoke(ctx, GatewayMonitoringService_CreateAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayMonitoringServiceClient) UpdateAlert(ctx context.Context, in *UpdateAlertRequest, opts ...grpc.CallOption) (*UpdateAlertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAlertResponse)
	err := c.cc.Invoke(ctx, GatewayMonitoringService_UpdateAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayMonitoringServiceClient) DeleteAlert(ctx context.Context, in *DeleteAlertRequest, opts ...grpc.CallOption) (*DeleteAlertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAlertResponse)
	err := c.cc.Invoke(ctx, GatewayMonitoringService_DeleteAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayMonitoringServiceServer is the server API for GatewayMonitoringService service.
// All implementations must embed UnimplementedGatewayMonitoringServiceServer
// for forward compatibility.
type GatewayMonitoringServiceServer interface {
	GetRealTimeMetrics(*GetRealTimeMetricsRequest, grpc.ServerStreamingServer[MetricData]) error
	GetAlerts(context.Context, *GetAlertsRequest) (*GetAlertsResponse, error)
	CreateAlert(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error)
	UpdateAlert(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error)
	DeleteAlert(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error)
	mustEmbedUnimplementedGatewayMonitoringServiceServer()
}

// UnimplementedGatewayMonitoringServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGatewayMonitoringServiceServer struct{}

func (UnimplementedGatewayMonitoringServiceServer) GetRealTimeMetrics(*GetRealTimeMetricsRequest, grpc.ServerStreamingServer[MetricData]) error {
	return status.Errorf(codes.Unimplemented, "method GetRealTimeMetrics not implemented")
}
func (UnimplementedGatewayMonitoringServiceServer) GetAlerts(context.Context, *GetAlertsRequest) (*GetAlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlerts not implemented")
}
func (UnimplementedGatewayMonitoringServiceServer) CreateAlert(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAlert not implemented")
}
func (UnimplementedGatewayMonitoringServiceServer) UpdateAlert(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAlert not implemented")
}
func (UnimplementedGatewayMonitoringServiceServer) DeleteAlert(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAlert not implemented")
}
func (UnimplementedGatewayMonitoringServiceServer) mustEmbedUnimplementedGatewayMonitoringServiceServer() {
}
func (UnimplementedGatewayMonitoringServiceServer) testEmbeddedByValue() {}

// UnsafeGatewayMonitoringServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayMonitoringServiceServer will
// result in compilation errors.
type UnsafeGatewayMonitoringServiceServer interface {
	mustEmbedUnimplementedGatewayMonitoringServiceServer()
}

func RegisterGatewayMonitoringServiceServer(s grpc.ServiceRegistrar, srv GatewayMonitoringServiceServer) {
	// If the following call pancis, it indicates UnimplementedGatewayMonitoringServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GatewayMonitoringService_ServiceDesc, srv)
}

func _GatewayMonitoringService_GetRealTimeMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRealTimeMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayMonitoringServiceServer).GetRealTimeMetrics(m, &grpc.GenericServerStream[GetRealTimeMetricsRequest, MetricData]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayMonitoringService_GetRealTimeMetricsServer = grpc.ServerStreamingServer[MetricData]

func _GatewayMonitoringService_GetAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitoringServiceServer).GetAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayMonitoringService_GetAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitoringServiceServer).GetAlerts(ctx, req.(*GetAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayMonitoringService_CreateAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitoringServiceServer).CreateAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayMonitoringService_CreateAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitoringServiceServer).CreateAlert(ctx, req.(*CreateAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayMonitoringService_UpdateAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitoringServiceServer).UpdateAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayMonitoringService_UpdateAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitoringServiceServer).UpdateAlert(ctx, req.(*UpdateAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayMonitoringService_DeleteAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayMonitoringServiceServer).DeleteAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayMonitoringService_DeleteAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayMonitoringServiceServer).DeleteAlert(ctx, req.(*DeleteAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayMonitoringService_ServiceDesc is the grpc.ServiceDesc for GatewayMonitoringService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayMonitoringService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "exoper.gateway.v1.GatewayMonitoringService",
	HandlerType: (*GatewayMonitoringServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAlerts",
			Handler:    _GatewayMonitoringService_GetAlerts_Handler,
		},
		{
			MethodName: "CreateAlert",
			Handler:    _GatewayMonitoringService_CreateAlert_Handler,
		},
		{
			MethodName: "UpdateAlert",
			Handler:    _GatewayMonitoringService_UpdateAlert_Handler,
		},
		{
			MethodName: "DeleteAlert",
			Handler:    _GatewayMonitoringService_DeleteAlert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRealTimeMetrics",
			Handler:       _GatewayMonitoringService_GetRealTimeMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/api/proto/gateway/gateway.proto",
}
